"use strict";(self.webpackChunkfirefox_ecosystem_platform=self.webpackChunkfirefox_ecosystem_platform||[]).push([[2129],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=o,k=p["".concat(l,".").concat(u)]||p[u]||h[u]||i;return n?a.createElement(k,r(r({ref:t},d),{},{components:n})):a.createElement(k,r({ref:t},d))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},34701:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return h}});var a=n(87462),o=n(63366),i=(n(67294),n(3905)),r=["components"],s={title:"onepw Protocol"},l="Firefox Accounts/Sync Protocol",c={unversionedId:"explanation/onepw-protocol",id:"explanation/onepw-protocol",title:"onepw Protocol",description:"This document describes the protocol used by FxA clients (including FF Sync clients) and the key-server implemented in the FxA auth-server. Clients use this protocol to prove their knowledge of the account password, for which they receive a sessionToken, which can be used to obtain a signed BrowserID certificate (which can be used to convince subsequent relying parties that they control the account). This protocol is also used to retrieve a pair of encryption keys (kA and kB) which will be used to encrypt Sync data.",source:"@site/docs/explanation/onepw-protocol.md",sourceDirName:"explanation",slug:"/explanation/onepw-protocol",permalink:"/ecosystem-platform/explanation/onepw-protocol",draft:!1,editUrl:"https://github.com/mozilla/ecosystem-platform/edit/master/docs/explanation/onepw-protocol.md",tags:[],version:"current",frontMatter:{title:"onepw Protocol"},sidebar:"docs",previous:{title:"Metrics",permalink:"/ecosystem-platform/explanation/metrics"},next:{title:"Scoped Keys",permalink:"/ecosystem-platform/explanation/scoped-keys"}},d={},h=[{value:"Client-Side Key Stretching",id:"client-side-key-stretching",level:2},{value:"Creating a Session",id:"creating-a-session",level:2},{value:"Email Verification",id:"email-verification",level:2},{value:"Using accountResetToken",id:"using-accountresettoken",level:2},{value:"Typical Client Flows",id:"typical-client-flows",level:2},{value:"vs. old-Sync",id:"vs-old-sync",level:2},{value:"vs. earlier SRP-based protocol",id:"vs-earlier-srp-based-protocol",level:2},{value:"Changing Server-Side Protections",id:"changing-server-side-protections",level:2},{value:"Changing Client-Side Protection",id:"changing-client-side-protection",level:2},{value:"two-password extension",id:"two-password-extension",level:2},{value:"pairing extension",id:"pairing-extension",level:2},{value:"client stretch-KDF",id:"client-stretch-kdf",level:3},{value:"/account/keys",id:"accountkeys",level:3},{value:"use session (certificate/sign, etc)",id:"use-session-certificatesign-etc",level:3}],p={toc:h};function u(e){var t=e.components,s=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"firefox-accountssync-protocol"},"Firefox Accounts/Sync Protocol"),(0,i.kt)("p",null,"This document describes the protocol used by FxA clients (including FF Sync clients) and the key-server implemented in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mozilla/fxa/tree/main/packages/fxa-auth-server"},"FxA auth-server"),". Clients use this protocol to prove their knowledge of the account password, for which they receive a ",(0,i.kt)("inlineCode",{parentName:"p"},"sessionToken"),", which can be used to obtain a signed BrowserID certificate (which can be used to convince subsequent relying parties that they control the account). This protocol is also used to retrieve a pair of encryption keys (",(0,i.kt)("inlineCode",{parentName:"p"},"kA")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"kB"),") which will be used to encrypt Sync data."),(0,i.kt)("p",null,"The protocol is designed to protect the user's data as best as possible given the design constraints (including the use of a single user password, and CPU+memory limitations of slow mobile clients). Other protocols will be introduced later, in environments that can handle them, to improve data protection further."),(0,i.kt)("p",null,"Note that all messages are delivered over an HTTPS connection. The client browser may also implement cert-pinning to improve on the certificate validation process. The protections described below are in addition to those provided by TLS."),(0,i.kt)("p",null,"This is the protocol used to manage FxA accounts and Sync clients for Firefox 29, due to be shipped in late April 2014. It replaces the J-PAKE -based pairing setup protocol that's been in use since Firefox 4.0."),(0,i.kt)("h1",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Clients have an email address and a password (which is never sent directly to the fxa-auth-server). A fairly simple protocol is used to prove knowledge of the password, which gives the client a session token that they can use later."),(0,i.kt)("p",null,"A slightly more complex protocol is used to obtain the sync encryption keys."),(0,i.kt)("p",null,'The server remembers several secrets per client. The main one is the "verifier hash", which is used to test the client\'s knowledge of the account password. The other two secrets are ',(0,i.kt)("inlineCode",{parentName:"p"},"kA")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"kA")," is the class-A sync key (for data which can be recovered through an email challenge link), and ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))")," is unwrapped by the client to get ",(0,i.kt)("inlineCode",{parentName:"p"},"kB")," (for data which can only be recovered by knowledge of the password)."),(0,i.kt)("p",null,"Note that the class-A key is not currently used for any sync data."),(0,i.kt)("h2",{id:"client-side-key-stretching"},"Client-Side Key Stretching"),(0,i.kt)("p",null,'"Key Stretching" is the practice of running a password through a computationally-expensive one-way function before using it for encryption or authentication. The goal is to make brute-force dictionary attacks more expensive, by raising the cost of testing each guess.'),(0,i.kt)("p",null,"To protect the user's class-B data against a TLS-breaking eavesdropper or active compromise of our keyserver (so the attacker gets to see ",(0,i.kt)("inlineCode",{parentName:"p"},"authPW")," as it is sent to the server), we perform some key stretching on the client. This makes it more difficult to brute-force the original password from ",(0,i.kt)("inlineCode",{parentName:"p"},"authPW"),". To further improve protection against static compromise (where the attacker sees the stored ",(0,i.kt)("inlineCode",{parentName:"p"},"verifyHash")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))")," in the server's database), we do additional stretching on the server. For details about how this stretching is used to wrap keys, see ",(0,i.kt)("a",{parentName:"p",href:"#fetching-sync-keys"},"Fetching Sync Keys"),", below."),(0,i.kt)("p",null,'On the server, we use the memory-hard "scrypt" function (pronounced "ess-crypt") for this purpose, as motivated by the attacker-cost studies in ',(0,i.kt)("a",{parentName:"p",href:"https://wiki.mozilla.org/Identity/CryptoIdeas/01-PBKDF-scrypt"},"Identity/CryptoIdeas/01-PBKDF-scrypt"),"."),(0,i.kt)("p",null,"The goal is to ensure all values in the server's long-term storage will require at least the hard scrypt-based stretch to test each password guess. All values sent over the wire or temporarily held in server memory should require at least the weaker PBKDF stretch for each guess."),(0,i.kt)("h1",{id:"creating-the-account"},"Creating The Account"),(0,i.kt)("p",null,"The first act performed by a user is to create the account. They enter email+password into their browser, which then does the following steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'runs 1000 rounds of PBKDF2, using the email address as a salt, to produce "quickStretchedPW"'),(0,i.kt)("li",{parentName:"ul"},'feed quickStretchedPW into HKDF to obtain "authPW"'),(0,i.kt)("li",{parentName:"ul"},"deliver (email, authPW) to the keyserver's ",(0,i.kt)("inlineCode",{parentName:"li"},"POST /account/create")," API")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of account creation flow",src:n(75865).Z,width:"940",height:"441"})),(0,i.kt)("p",null,"The server creates a random 32-byte ",(0,i.kt)("inlineCode",{parentName:"p"},"authSalt"),", and uses it to stretch ",(0,i.kt)("inlineCode",{parentName:"p"},"authPW")," further, using scrypt (64k/8/1), to derive ",(0,i.kt)("inlineCode",{parentName:"p"},"bigStretchedPW")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"verifyHash"),". It then stores ",(0,i.kt)("inlineCode",{parentName:"p"},"authSalt")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"verifyHash")," in the database."),(0,i.kt)("p",null,"In addition, the server creates both ",(0,i.kt)("inlineCode",{parentName:"p"},"kA")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))")," as randomly-generated 256-bit (32-byte) strings. It stores these, along with all the remaining values, indexed by email, in the account table where they can be retrieved later."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/create")," call allocates and returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"sessionToken")," (described below), just as if the client had immediately performed a login. In addition, if the ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/create")," request path included a queryarg of ",(0,i.kt)("inlineCode",{parentName:"p"},"keys=true"),", the call will allocate and return a ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken")," (also described below)."),(0,i.kt)("p",null,'To prevent fixation attacks, we require new accounts to verify their configured recovery email address before letting them learn the generated keys or obtain a signed certificate. The server will send email with a URL that contains a long random "verification code" in a query argument. This URL points to a static page with some javascript that submits the code to the ',(0,i.kt)("inlineCode",{parentName:"p"},"POST /account/recovery_methods/verify_code")," API. The URL can be clicked by any browser (it is not bound to anything), and when the API is hit, the account is marked as verified."),(0,i.kt)("p",null,"The account will issue sessionTokens and keyFetchTokens without email verification, but they cannot be used (for much) until verification is complete."),(0,i.kt)("h1",{id:"login-obtaining-the-sessiontoken"},"Login: Obtaining the sessionToken"),(0,i.kt)("p",null,"To connect a browser to an existing account, we use the following login protocol to transform an email+password pair into a sessionToken. The sessionToken will be used in the next section to obtain signed certificates."),(0,i.kt)("p",null,'This protocol starts by feeding the password and email address into 1000 rounds of PBKDF2 to obtain "quickStretchedPW", feeding quickStretchedPW into HKDF to get "authPW", then delivering email+authPW to the server\'s ',(0,i.kt)("inlineCode",{parentName:"p"},"/account/login")," endpoint."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of auth flow",src:n(63144).Z,width:"960",height:"590"})),(0,i.kt)("p",null,'The server uses the email address to look up the database row, extracts authSalt, performs the same stretching as during account creation to obtain "bigStretchedPW" and then "verifyHash", then compares verifyHash against the stored value. If they match, the client has proven knowledge of the password, and the server creates a new session. The server returns the newly-generated sessionToken to the client, along with its account identifier (uid).'),(0,i.kt)("p",null,"In the future, the ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login"),' endpoint may also accept two-factor authentication data. If so, it is likely to return a "2FA-required" error to the first request, with information on what additional UI should be displayed to solicit the additional data. The response should also indicate an "account mode", with a known string for this first (one-password) mode. When we add the two-password mode (described below), any account which has been moved to the new mode will return a different string, and then older clients (who don\'t understand the new mode) should display an error to the user prompting them to use a newer version of the client.'),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login")," call should also include information about the client device, such as a host name, profile name, model number, etc. This will be used to describe the session to the user later, when they enumerate their active sessions (for review and possible revocation)."),(0,i.kt)("p",null,"If the client wants to get encryption keys for Sync in addition to signed certificates, it should use ",(0,i.kt)("inlineCode",{parentName:"p"},"POST /account/login?keys=true"),", which returns a keyFetchToken in addition to the usual sessionToken."),(0,i.kt)("h2",{id:"creating-a-session"},"Creating a Session"),(0,i.kt)("p",null,"Each successful call to ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login?keys=true")," results in a new session (with a unique+unguessable sessionToken). The server can support multiple sessions per account (typically one per client device, plus perhaps others for account-management portals). The sessionToken lasts forever (until revoked by a password change or explicit revocation command), and can be used an unlimited number of times."),(0,i.kt)("p",null,'Many keyserver APIs require a HAWK-protected request that uses the sessionToken. Some of them require that the account be in the "verified" state.'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"GET /account/devices"),(0,i.kt)("li",{parentName:"ul"},"POST /session/destroy"),(0,i.kt)("li",{parentName:"ul"},"GET /recovery_email/status"),(0,i.kt)("li",{parentName:"ul"},"POST /recovery_email/resend_code"),(0,i.kt)("li",{parentName:"ul"},'POST /certificate/sign (requires "verified" account)')),(0,i.kt)("h2",{id:"email-verification"},"Email Verification"),(0,i.kt)("p",null,"As above, to prevent fixation attacks, new accounts must verify their email address before they can learn keys or obtain a certificate. Nevertheless, we wish clients to forget the user's password while they wait for email verification to complete. To achieve this, clients can obtain a sessionToken before verification, but most APIs that require it will raise errors until verification is finished."),(0,i.kt)("p",null,"A successful ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login")," response includes information about the verification status of the account. If necessary, the client can use ",(0,i.kt)("inlineCode",{parentName:"p"},"/recovery_email/status")," endpoint (which requires a sessionToken but not account verification) until the user clicks the email link and the API reports verification is complete. Then the client can use ",(0,i.kt)("inlineCode",{parentName:"p"},"GET /account/keys")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"POST /certificate/sign"),", described below."),(0,i.kt)("p",null,"If the client merely wants certificates and doesn't care about encryption keys, it can use ",(0,i.kt)("inlineCode",{parentName:"p"},"POST /account/login")," instead. This returns a sessionToken but not a keyFetchToken."),(0,i.kt)("h1",{id:"signing-certificates"},"Signing Certificates"),(0,i.kt)("p",null,"Clients who have a active sessionToken, for an account on which the email address has been verified, can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"/certificate/sign")," endpoint to obtain a signed BrowserID/Persona certificate. This certificate can then be used to produce signed BrowserID assertions for delivery to RPs."),(0,i.kt)("p",null,"The sessionToken is used to derive two values:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"tokenID"),(0,i.kt)("li",{parentName:"ul"},"request HMAC key")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of certificate creation flow",src:n(52720).Z,width:"636",height:"415"})),(0,i.kt)("p",null,'The requestHMACkey is used in a HAWK request to provide integrity over many APIs, including /certificate/sign. requestHMACkey is used as credentials.key, while tokenID is used as credentials.id . HAWK includes the URL and the HTTP method ("POST") in the HMAC-protected data, and will optionally include the HTTP request body (payload) if requested.'),(0,i.kt)("h1",{id:"fetching-sync-keys"},"Fetching Sync Keys"),(0,i.kt)("p",null,"If the client also wants kA/kB for Sync, it uses ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login?keys=true")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login"),". When the server sees this, in addition to creating a sessionToken, it also allocates a random ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken")," and prepares an encrypted response for a future call that will redeem this token."),(0,i.kt)("p",null,"The client will use keyFetchToken (as described below) to obtain ",(0,i.kt)("inlineCode",{parentName:"p"},"kA")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))"),". It will then use ",(0,i.kt)("inlineCode",{parentName:"p"},"quickStretchedPW")," to derive ",(0,i.kt)("inlineCode",{parentName:"p"},"unwrapBKey"),", from which it can obtain the unwrapped ",(0,i.kt)("inlineCode",{parentName:"p"},"kB"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of key derivation flow",src:n(54287).Z,width:"950",height:"543"})),(0,i.kt)("p",null,"During the ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login?keys=true")," call, the server extracts a second value from its HKDF call named ",(0,i.kt)("inlineCode",{parentName:"p"},"wrapwrapKey"),". It uses ",(0,i.kt)("inlineCode",{parentName:"p"},"wrapwrapKey")," to unwrap ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))")," from its database (with a simple XOR) to derive ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(kB)")," and holds this temporarily in memory for the duration of the request (it is never written to the database unencrypted)."),(0,i.kt)("p",null,"The server then uses ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken")," to derive ",(0,i.kt)("inlineCode",{parentName:"p"},"tokenID"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"reqHMACkey"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"keyRequestKey"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"keyRequestKey")," is used to derive ",(0,i.kt)("inlineCode",{parentName:"p"},"respHMACkey")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"respXORkey"),". The server concatenates ",(0,i.kt)("inlineCode",{parentName:"p"},"kA")," and the temporary copy of ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(kB)"),", then encrypts the pair by XORing it with ",(0,i.kt)("inlineCode",{parentName:"p"},"respXORkey"),", and attaches a MAC generated with ",(0,i.kt)("inlineCode",{parentName:"p"},"respHMACkey"),". It stores (",(0,i.kt)("inlineCode",{parentName:"p"},"reqHMACkey"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"encryptedResponse"),") in a short-lived database table indexed by ",(0,i.kt)("inlineCode",{parentName:"p"},"tokenID"),", and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"sessionToken")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken")," to the client."),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(kB)")," are ",(0,i.kt)("em",{parentName:"p"},"not")," stored in the database. The goal is to make sure that nothing stored in the database enables an easy brute-force attack on the user's password: all saved values must include the long scrypt stretch in their derivation or protection."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of server side of GET /account/keys request",src:n(36184).Z,width:"921",height:"543"})),(0,i.kt)("p",null,"Later, the client will use ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken")," to derive the same values as the server did, and uses ",(0,i.kt)("inlineCode",{parentName:"p"},"tokenID")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"reqHMACkey"),' to make a HAWK request to the "GET /account/keys" API. The server looks up the stored table entry with ',(0,i.kt)("inlineCode",{parentName:"p"},"tokenID"),", checks the request HMAC for validity, then returns the pre-encrypted response and deletes the entry."),(0,i.kt)("p",null,"The client recomputes the MAC, compares it (throwing an error if it doesn't match), extracts the ciphertext, XORs it with the derived respXORkey, then splits it into the separate kA and wrap(kB) values."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of client side of GET /account/keys request",src:n(28785).Z,width:"823",height:"620"})),(0,i.kt)("p",null,"Finally, the server-provided wrap(kB) value is simply XORed with the password-derived unwrapBKey (both are 32-byte strings) to obtain kB. There is no MAC on wrap(kB)."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Small diagram of kB unwrap flow",src:n(81954).Z,width:"430",height:"141"})),(0,i.kt)("p",null,'"kA" and "kB" enable the browser to encrypt/decrypt synchronized data records. They will be used to derive separate encryption and HMAC keys for each data collection (bookmarks, form-fill data, saved-password, open-tabs, etc). This will allow the user to share some data, but not everything, with a third party. The client may intentionally forget kA and kB (only retaining the derived keys) to reduce the power available to someone who steals their device.'),(0,i.kt)("p",null,"Note that /account/keys will not succeed until the account's email address has been verified, which could take hours or days if the user does not respond to the challenge email promptly. Also note that each keyFetchToken is single-use and short-lived: it will only be used for a specific kA/wrapKB message, and expires immediately if/when the account password is changed."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Crypto note: while the two returned keys are encrypted with (a derivative of) keyFetchToken, the keyFetchToken itself is sent over the (TLS-protected) wire without additional protection. This encryption protects the short-term server key-fetch-token table (indexed by ",(0,i.kt)("inlineCode",{parentName:"p"},"tokenID"),") from brute-force attacks: if the server stored ",(0,i.kt)("inlineCode",{parentName:"p"},"wrapwrapKey")," until the key-fetch token were redeemed, a database breach would yield ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(kB)")," which only provides weak (PBKDF) protection against dictionary attacks. In addition, this encryption step minimizes the changes to our existing (SRP-based) code, and may become more meaningful in a future protocol which uses SRP to protect the keyFetchToken in transit."))),(0,i.kt)("p",null,"We use the ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/keys")," API (instead of merely returning the keys directly in ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"password/change/start"),") so that clients can forget the master password while they wait for the recovery email to be verified. If there were not a second key-fetch API, clients would need to poll with ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login")," repeatedly until verification had finished, requiring both the original password and a new server-side keystretch operation each time."),(0,i.kt)("h1",{id:"changing-the-password"},"Changing the Password"),(0,i.kt)("p",null,"The account may be reset in two circumstances: when the user changes their password (i.e. they still know the old password), or when the user forgets their password."),(0,i.kt)("p",null,"To change the password from one known value to another, the client uses a two-phase API. They start with a message to the ",(0,i.kt)("inlineCode",{parentName:"p"},"/password/change/start")," endpoint. This accepts the same email and old-authPW that ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/login?keys=true")," takes, and returns both a ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken")," and a newly-allocated ",(0,i.kt)("inlineCode",{parentName:"p"},"passwordChangeToken"),"."),(0,i.kt)("p",null,"Clients should then use the ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken")," and their old ",(0,i.kt)("inlineCode",{parentName:"p"},"unwrapBkey")," to obtain and unwrap kB, then re-wrap it with the new ",(0,i.kt)("inlineCode",{parentName:"p"},"unwrapBkey")," derived from their new password. This allows the password-changing client to retain their class-B data. ",(0,i.kt)("inlineCode",{parentName:"p"},"kA")," is unchanged (and uninvolved in the protocol), so they retain their class-A data too."),(0,i.kt)("p",null,"Finally, the client sends the new ",(0,i.kt)("inlineCode",{parentName:"p"},"authPW")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(kB)")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"/password/change/finish")," endpoint, which is HAWK-authenticated by the ",(0,i.kt)("inlineCode",{parentName:"p"},"passwordChangeToken"),". If accepted, the server generates a new random ",(0,i.kt)("inlineCode",{parentName:"p"},"authSalt"),", derives the new ",(0,i.kt)("inlineCode",{parentName:"p"},"verifyHash"),", encrypts ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(kB)")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))"),", and commits all three to the account database."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of change password flow",src:n(39951).Z,width:"961",height:"728"})),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"passwordChangeToken")," is single-use and expires quickly, within 10 minutes."),(0,i.kt)("p",null,"When the account is reset (for any reason), all active sessions and tokens will be cancelled (disconnecting all devices from the account). The client should immediately establish a new session as described above."),(0,i.kt)("h1",{id:"handling-a-forgotten-password"},"Handling a Forgotten Password"),(0,i.kt)("p",null,"When the user has forgotten their password, they will use a web-based flow to reset the account. This starts by visiting a page on the fxa-content-server, continues by sending an email with a secret code to the user, then finishes when the user clicks on a link in that email and establishes a new password."),(0,i.kt)("p",null,"Note that, since the forgotten-password client never learns ",(0,i.kt)("inlineCode",{parentName:"p"},"kB"),", any class-B data will be lost. This is necessary to protect class-B data from attackers who can read the users's email but do not know the account password (including those who compromise the IdP and the keyserver itself). When using ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/reset")," below, the server generates a new random ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))")," (just as it does during account creation). ",(0,i.kt)("inlineCode",{parentName:"p"},"kA")," remains unchanged, allowing the user to recover their class-A data."),(0,i.kt)("p",null,'The fxa-content-server "forgot my password" page takes the user\'s email address and submits it to the ',(0,i.kt)("inlineCode",{parentName:"p"},"/password/forgot/send_code")," API (other recovery methods may be added in the future, like a phone number for SMS, but for now we only handle email). This API is unauthenticated (after all, the user who has forgotten their password knows nothing but their email address)."),(0,i.kt)("p",null,'The server marks the corresponding account as "pending recovery", allocates a random passwordForgotToken for the account, creates a recovery code, and sends email to the user with instructions and a URL (pointing at the fxa-content-server) with both the passwordForgotToken and the recovery code as query-args.'),(0,i.kt)("p",null,"When the user clicks this link, the fxa-content-server page that gets loaded will submit the token and code to the ",(0,i.kt)("inlineCode",{parentName:"p"},"/password/forgot/verify_code")," API. When the server sees a matching token and code, it allocates an ",(0,i.kt)("inlineCode",{parentName:"p"},"accountResetToken")," and returns it to the client (page) that submitted them. The client can then use the ",(0,i.kt)("inlineCode",{parentName:"p"},"accountResetToken")," to establish a new password as described below. This all takes place in a web browser."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of forgot password flow",src:n(61627).Z,width:"903",height:"445"})),(0,i.kt)("p",null,"The API uses a distinct token and code for historical reasons: the original scheme assumed an agent-based flow instead of a web-based one, in which the user's browser chrome (or other client) would remember the passwordForgotToken while waiting for the user to transcribe the recovery code from the email into the client. In that scheme, the code needed to be short enough to transcribe, and there were additional security considerations involving limited re-use of the ",(0,i.kt)("inlineCode",{parentName:"p"},"passwordForgotToken")," and code length. In the new web-based flow, the recovery code is a full-strength (256-bit) random string."),(0,i.kt)("h2",{id:"using-accountresettoken"},"Using accountResetToken"),(0,i.kt)("p",null,"The client puts their new password through the same stretching procedure as described in the new-account section above, resulting in a new authPW. The client then uses the accountResetToken to HAWK-authenticate a request to the ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/reset")," API, including the new authPW."),(0,i.kt)("p",null,"If the request is accepted, the server generates a new random authSalt, computes a new verifyHash, and stores verifyHash in the database. It also creates a new random ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))"),' value, cancels all active sessions and tokens (disconnecting all devices from the account), and sends a "your password has been changed" email to the user (perhaps including the IP address of the client which used the API).'),(0,i.kt)("p",null,"All class-B data will be lost. The ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/reset")," API is just like the ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/create")," API, except that it is HAWK-authenticated by an accountResetToken, and requires that the email already be in the database (as opposed to forbidding that)."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of password reset flow",src:n(8147).Z,width:"961",height:"463"})),(0,i.kt)("p",null,"accountResetToken is used to derive ",(0,i.kt)("inlineCode",{parentName:"p"},"tokenID")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"requestHMACkey")," as usual, then the request data is delivered in the body of a HAWK request that uses tokenID as credentials.id and requestHMACkey as credentials.key ."),(0,i.kt)("p",null,"After using ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/reset"),", clients should immediately perform the login protocol from above: a new sessionToken is required, since old sessions and tokens are revoked by ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/reset"),". Clients can retain the new authPW value during this process to avoid needing to run the key-stretching routine a second time."),(0,i.kt)("h1",{id:"deleting-the-account"},"Deleting The Account"),(0,i.kt)("p",null,"When the user wishes to completely delete their account, the browser needs to perform two actions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"contact the storage servers and delete all records and collections"),(0,i.kt)("li",{parentName:"ul"},"contact the keyserver and delete the account information")),(0,i.kt)("p",null,"The user should be prompted for their password as confirmation (i.e. a browser in the normal attached-and-synchronizing state should not be able to erase the account information: it must prove recent knowledge of the password)."),(0,i.kt)("p",null,"The device submits ",(0,i.kt)("inlineCode",{parentName:"p"},"authPW")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"/account/destroy")," endpoint. This request contains no body and returns only a success code."),(0,i.kt)("h1",{id:"keyserver-protocol-summary"},"Keyserver Protocol Summary"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'* POST /account/create (email,authPW) -> ok (server sends verification email)\n  * creates a user account\n* POST /account/login (email, authPW) -> sessionToken, emailVerified\n* POST /account/login?keys=true (authPW) -> sessionToken, keyFetchToken, emailVerified\n* GET /account/devices {sessionToken} () -> list of devices\n* GET /account/keys {keyFetchToken,needs-verf} () -> kA/wrap(kB)\n  * single-use, only if email is verified, encrypted results\n* POST /account/reset {accountResetToken} (newAuthPW) -> ok\n  * single-use, does not require email to be verified, revoke all tokens for account, send notification email to user\n* POST /account/delete (authPW) -> ok, account deleted\n* POST /session/destroy {sessionToken} () -> ok\n  * for detaching a device, destroy all tokens\n* POST /recovery_email/status {sessionToken} () -> "verified" status of email\n  *  use "Accept: text/event-stream" header for server-sent-events; server will send "update" event with the new content of the resource any time it changes.\n* POST /recovery_email/resend_code {sessionToken} () -> re-send verification email\n* POST /recovery_email/verify_code (code) -> set "verified" flag\n  * this code will come from a clickable link and is an unauthenticated endpoint\n  * this could maybe take the recovery method if that would be helpful\n  * sets verified flag on recovery method\n* POST /certificate/sign {sessionToken,needs-verf} (pubkey) -> cert\n  * only if recovery email is verified\n* POST /password/change/start {needs-verf} (email, authPW) -> keyFetchToken, passwordChangeToken\n* POST /password/change/finish {passwordChangeToken} (newAuthPW, newWrapKB) -> ok\n* POST /password/forgot/send_code () -> passwordForgotToken\n  * sends code to recovery method (email for now, maybe SMS later)\n  * this is a short code, not a clickable link\n* POST /password/forgot/resend_code {passwordForgotToken} -> re-sends code\n* POST /password/forgot/verify_code {passwordForgotToken} (code) -> accountResetToken\n  * sets verified flag on recovery method\n* POST /get_random_bytes\n')),(0,i.kt)("h2",{id:"typical-client-flows"},"Typical Client Flows"),(0,i.kt)("p",null,"Create account"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* POST /account/create (email,authPW) -> ok (server sends verification email)\n* POST /account/login (email, authPW) -> sessionToken, verifiedStatus (=false)\n* GET /recovery_email/status {sessionToken} () -> verifiedStatus\n  * optional (only if user requests resend):\n    * POST /recovery_email/resend_code {sessionToken}() -> ok\n  * POST /recovery_email/verify_code (code) -> ok\n* POST /certificate/sign {sessionToken} (pubkey) -> cert\n")),(0,i.kt)("p",null,"Attach to new device"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* POST /account/login (email, authPW) -> sessionToken, verifiedStatus\n  * if not verified, poll until verified\n* POST /certificate/sign {sessionToken} (pubkey) -> cert\n")),(0,i.kt)("p",null,"Attach new device for Sync"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* POST /account/login?keys=true (email, authPW) -> sessionToken, keyFetchToken, verifiedStatus\n  * if not verified, poll until verified\n* GET /account/keys {keyFetchToken,needs-verf} () -> kA/wrap(kB)\n* POST /certificate/sign {sessionToken} (pubkey) -> cert\n")),(0,i.kt)("p",null,"Forgot password"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'* POST /password/forgot/send_code (email) -> passwordForgotToken\n* POST /password/forgot/verify_code {passwordForgotToken} (code) ->  accountResetToken\n* POST /account/reset {accountResetToken} (newAuthPW) -> ok\n* GOTO "Attach to new device"\n')),(0,i.kt)("p",null,"Change Password"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'* POST /password/change/start {needs-verf} (email, authPW) -> keyFetchToken, passwordChangeToken\n* GET /account/keys {keyFetchToken} () -> kA/wrap(kB)\n* POST /password/change/finish {passwordChangeToken} (newAuthPW, newWrapKB) -> ok\n* GOTO "Attach to new device"\n')),(0,i.kt)("h1",{id:"hawk-notes"},"HAWK Notes"),(0,i.kt)("p",null,"The following calls are HAWK-authenticated by some sort of token:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"GET /account/devices"),(0,i.kt)("li",{parentName:"ul"},"GET /account/keys"),(0,i.kt)("li",{parentName:"ul"},"POST /account/reset"),(0,i.kt)("li",{parentName:"ul"},"POST /session/destroy"),(0,i.kt)("li",{parentName:"ul"},"POST /recovery_email/status"),(0,i.kt)("li",{parentName:"ul"},"POST /recovery_email/resend_code"),(0,i.kt)("li",{parentName:"ul"},"POST /certificate/sign"),(0,i.kt)("li",{parentName:"ul"},"POST /password/change/finish")),(0,i.kt)("p",null,"These calls use HKDF to derive two values from the token:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"tokenID"),(0,i.kt)("li",{parentName:"ul"},"reqHMACkey")),(0,i.kt)("p",null,"The client uses tokenID and reqHMACkey for a HAWK (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hueniverse/hawk/"},"https://github.com/hueniverse/hawk/"),') request to the API endpoint, using tokenID as "credentials.id" and reqHMACkey as "credentials.key". The server uses tokenID to look up the corresponding token, then derives reqHMACkey to validate the request.'),(0,i.kt)("p",null,"All tokens have an associated tokenID. For all tokens other than ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken"),", the server needs to maintain a table that maps the tokenID to the token itself, so it can derive other values from the token later. For ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken"),", the table should map tokenID to only reqHMACkey and the pre-encrypted response, to avoid retaining anything that could be used to decrypt the response."),(0,i.kt)("p",null,"Each token is associated with a specific account, so later API requests do not need to specify an email address or account ID."),(0,i.kt)("p",null,"HAWK offers optional payload verification for requests, by including a hash of the payload contents in the serialized headers (which are then HMACed). All onepw clients SHOULD include this payload hash. Most HAWK client libraries automatically include the hash, but we have one instance (the Java-based Firefox-on-Android client, see ",(0,i.kt)("a",{parentName:"p",href:"https://bugzilla.mozilla.org/show_bug.cgi?id=986664"},"bug 986664"),") which omits the hash on one call. Therefore, the server does not currently enforce the payload hash on all requests (",(0,i.kt)("a",{parentName:"p",href:"https://bugzilla.mozilla.org/show_bug.cgi?id=985766"},"bug 985766"),")."),(0,i.kt)("p",null,"This is safe, because all requests are delivered inside a TLS-protected channel: any attacker who could see (and then modify) a valid request would also be able to learn the token which signed it. Payload validation was more important in the previous SRP-based protocol, which was designed to avoid reliance on TLS: all requests and responses were validated, and all tokens encrypted with keys that derive from the SRP session key."),(0,i.kt)("p",null,'So payload protection is a "nice-to-have", not a requirement. New clients should send the hash. Once we\'ve fixed the android client, and the number of old android clients drops below some comfortable threshold, we will change the server to require payload hashes for all POST requests.'),(0,i.kt)("h1",{id:"crypto-notes"},"Crypto Notes"),(0,i.kt)("p",null,"Strong entropy is needed in the following places:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"(server) initial creation kA, wrap(wrap(kB)), and authSalt"),(0,i.kt)("li",{parentName:"ul"},"(server) creation of sessionToken, keyFetchToken, accountResetToken, passwordChangeToken, and passwordForgotToken")),(0,i.kt)("p",null,'On the server, code should get entropy from /dev/urandom via a function that uses it, like "crypto.randomBytes()" in node.js or "os.urandom()" in python.'),(0,i.kt)("p",null,"An HKDF-based stream cipher is used to protect the contents of some requests. HKDF is used to create a number of random bytes equal to the length of the message, then these are XORed with the plaintext to produce the ciphertext. An HMAC is then computed from the ciphertext, to protect the integrity of the message."),(0,i.kt)("p",null,'HKDF, like any KDF, is defined to produce output that is indistinguishable from random data ("The HKDF Scheme", ',(0,i.kt)("a",{parentName:"p",href:"http://eprint.iacr.org/2010/264.pdf"},"http://eprint.iacr.org/2010/264.pdf")," , by Hugo Krawczyk, section 3). XORing a plaintext with a random keystream to produce ciphertext is a simple and secure approach to data encryption, epitomized by AES-CTR or a stream cipher (",(0,i.kt)("a",{parentName:"p",href:"http://cr.yp.to/snuffle/design.pdf"},"http://cr.yp.to/snuffle/design.pdf"),"). HKDF is not the fastest way to generate such a keystream, but it is safe, easy to specify, and easy to implement (just HMAC and XOR)."),(0,i.kt)("p",null,"Each keystream must be unique. We define keyFetchToken to be a single-use randomly-generated value, to ensure our HKDF-XOR keystreams will be unique."),(0,i.kt)("p",null,"A slightly more-traditional alternative would be to use AES-CTR (with the same HMAC-SHA256 used here), with a randomly-generated IV. This is equally secure, but requires implementors to obtain an AES library (with CTR mode, which does not seem to be universal). An even more traditional technique would be AES-CBC, which introduces the need for padding and a way to specify the length of the plaintext. The additional specification complexity, plus the library load, leads me to prefer HKDF+XOR."),(0,i.kt)("p",null,"kB is equal to the XOR of wrapKey (which is a deterministic function of the user's email address, password, and hard-coded stretching parameters), the server's wrapwrapKey (a deterministic function of user's email address, password, the server's stretching parameters, and the server-side ",(0,i.kt)("inlineCode",{parentName:"p"},"authSalt"),"), and the server's randomly-generated ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))")," value, making kB a random value too. Using XOR as a wrapping function allows us to avoid sending any derivative of kB in the initial createAccount arguments, or depending upon client-side entropy sources."),(0,i.kt)("p",null,"To make this technique safe, any time kB or the password is changed, the authSalt should be changed too. Otherwise knowledge of both wrap(wrap(old-kB)) and old-kB would reveal wrapKey, making it easy to deduce the new kB. Changing authSalt causes wrapwrapKey to change too, preventing this."),(0,i.kt)("p",null,"There is no MAC on wrap(kB). If the keyserver chooses to deliver a bogus wrap(kB) or kA, the client might discover the problem a moment later when it attempts to use the key, or not, depending upon the high-level protocol. Sync, our first client, uses the tuple of (email, hash(kB), cert-generation-number) to identify a pool of stored user data. So Sync clients which receive a corrupt key will find themselves in an isolated pool, and will believe themselves to be the only device connected to their Sync account."),(0,i.kt)("p",null,"It might be useful to add a checksum to kA and wrap(kB) to detect accidental corruption (e.g. store and deliver kA+SHA256(kA), or wrap(kB)+HMAC(unwrapBkey, wrap(kB))), but this doesn't protect against intentional changes, and a MAC on kB would introduce an additional oracle to feed a dictionary attack. We omit this checksum for now, assuming that disks will be reliable enough to let us never experience such failures."),(0,i.kt)("h1",{id:"security-analysis"},"Security Analysis"),(0,i.kt)("p",null,"This protocol aims to have two main security properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'a "passive" attacker (who can read the server\'s stored database contents) gets to do two things: 1: learn kA. 2: perform a "hard" brute-force attack against the password, where "hard" means they must do 64k/8/1-scrypt for each password guess.'),(0,i.kt)("li",{parentName:"ul"},'an "active" attacker (one who can eavesdrop on TLS connections, or who compromises the running keyserver, and can thus observe messages sent to/from the clients) gets to do three things. 1: learn kA. 2: control the account (i.e. produce assertions). 3: perform an "easy" brute-force attack against the password (and thus kB), where "easy" means they must do 1000 rounds of PBKDF for each guessed password they want to test.')),(0,i.kt)("p",null,"This is weaker than the earlier SRP-based protocol, but still stronger than common industry practice, and significantly easier for clients to implement. In particular, clients do not need to perform scrypt-based stretching or SRP."),(0,i.kt)("p",null,"As with the SRP-based protocol, if the client is implemented in web content, then a strong active attacker (who can MitM TLS connections and thus serve doctored client code) can bypass the entire protocol and learn the password directly. This, of course, includes a server who decides (or is coerced) into delivering such pages."),(0,i.kt)("p",null,'The long-term server data is intended to be safe against "easy" dictionary attacks, meaning that given everything stored in the DB, a passive attacker must still perform the full scrypt stretch to test each password guess.'),(0,i.kt)("p",null,'The passive attacker gets access to two values that serve as password-guessing oracles. The first is "verifyHash", which is derived from the output of the full scrypt-based stretch. The second is ',(0,i.kt)("inlineCode",{parentName:"p"},"wrap(wrap(kB))")," (which could be used in conjunction with some class-B encrypted data to test passwords), which is also protected by the scrypt step: for each password, the attacker runs the full computation to derive kB, then tries to decrypt some data and sees if its HMAC check passes."),(0,i.kt)("p",null,"The stored pre-encrypted response to ",(0,i.kt)("inlineCode",{parentName:"p"},"GET /account/keys")," would also serve as an oracle, but the server explicitly doesn't retain the ",(0,i.kt)("inlineCode",{parentName:"p"},"keyFetchToken")," that encrypts it. Since keyFetchToken is randomly generated and independent of the user's password, the data it encrypts does not help test password guesses."),(0,i.kt)("h2",{id:"vs-old-sync"},"vs. old-Sync"),(0,i.kt)("p",null,"Given the Sync legacy of full-strength random keys, exchanged with J-PAKE pairing, we'd like to make it possible to achieve similar levels of security with the new protocol. When viewed from the perspective of old-Sync, this new protocol has the following weaknesses:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Passwords. All security, even against (rate-limited) online attacks, is limited by the strength of the user's password. old-Sync (nominally) had no passwords, and no practical amount of guessing would yield the account's encryption key.  Moderate-strength passwords can benefit from expensive stretching, but users with a password of \"123456\" will probably lose control of their account no matter what we do."),(0,i.kt)("li",{parentName:"ul"},"Password Reuse. If a user has a strong password but it's not unique, there is a risk that it maybe compromised on another service. Old-Sync (nominally) had no passwords, and as such password reuse was not possible."),(0,i.kt)("li",{parentName:"ul"},"Weak client-side stretching: the server (or someone who successfully compromises it), or an attacker who can forge TLS certificates (or who records traffic and later learns the server's TLS private key), both get enough information to perform a dictionary attack that is only limited by the weak PBKDF-based stretch. This is relatively cheap."),(0,i.kt)("li",{parentName:"ul"},"Use of Password in a Web Context: when the client of this protocol runs inside a web page, rather than in browser chrome, a new set of attacks become possible. Compromised/coerced servers can quietly deliver modified pages which reveal the user's password to a waiting attacker. This becomes more likely as the scope of Firefox Accounts grows to include new use cases which preclude a chrome-only client (e.g. signing into Marketplace from other web browsers). This same problem exists with corrupted browser updates, of course, but it is nominally possible to download a browser from a trusted source and disable automatic updates, whereas it is not feasible to prevent or even detect surreptitious web-page tampering.")),(0,i.kt)("p",null,"These weaknesses are the result of compromises. The features obtained in this bargain are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"recover account data (with the password) after losing your only device"),(0,i.kt)("li",{parentName:"ul"},"add a new device without access to an old device"),(0,i.kt)("li",{parentName:"ul"},"use slow/old clients (rather than doing expensive scrypt stretching client-side)"),(0,i.kt)("li",{parentName:"ul"},"generalized Firefox Accounts, with more features than just Sync")),(0,i.kt)("h2",{id:"vs-earlier-srp-based-protocol"},"vs. earlier SRP-based protocol"),(0,i.kt)("p",null,"Relative to the SRP-based protocol described in ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.mozilla.org/Identity/AttachedServices/KeyServerProtocol"},"https://wiki.mozilla.org/Identity/AttachedServices/KeyServerProtocol"),' , this "onepw" protocol has the following weaknesses:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'a TLS-level eavesdropper learns authPW (allowing them to control the account), learns kA (revealing all class-A data), and learns wrap(kB) ("easy" brute-force attack)'),(0,i.kt)("li",{parentName:"ul"},'the auth server gets an "easy" brute-force attack (by knowing authPW or wrap(kB))')),(0,i.kt)("p",null,"In exchange for these weaknesses, this protocol gains the following advantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"simpler client: no SRP necessary"),(0,i.kt)("li",{parentName:"ul"},"faster client: less client-side stretching"),(0,i.kt)("li",{parentName:"ul"},"server can upgrade protection of stored data (e.g. do more stretching) with minimal client involvement")),(0,i.kt)("h1",{id:"extensions"},"Extensions"),(0,i.kt)("h2",{id:"changing-server-side-protections"},"Changing Server-Side Protections"),(0,i.kt)("p",null,"If we need to change the scrypt stretching parameters (or move to some other algorithm entirely), the server can do this any time the user logs in or otherwise presents ",(0,i.kt)("inlineCode",{parentName:"p"},"authPW"),". The server should store some version marker in the database with each account row, to perform the same stretching each time, but can use different values for different accounts. The requirements are that the server can 1: compare ",(0,i.kt)("inlineCode",{parentName:"p"},"authPW")," against an earlier value, 2: return the same ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap(kB)")," as was submitted earlier, and 3: provides adequate protection against database compromise."),(0,i.kt)("p",null,"Likely changes include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"store verifyHash and ",(0,i.kt)("inlineCode",{parentName:"li"},"wrap(wrap(kB))")," in encrypted form, protected by an HSM, or with a key that is manually typed into the server instead of being stored on disk"),(0,i.kt)("li",{parentName:"ul"},"adding two-factor (2FA) verifiers to the database")),(0,i.kt)("h2",{id:"changing-client-side-protection"},"Changing Client-Side Protection"),(0,i.kt)("p",null,"We can change the client-side stretching parameters (perhaps to increase the number of PBKDF2 rounds) without affecting the server's behavior (it only sees ",(0,i.kt)("inlineCode",{parentName:"p"},"authPW"),", and doesn't care how the client derives it). But we would need a way to coordinate such changes among the various clients using this account. We might define a v2 API which adds an extra round-trip: starting by submitting an email address and getting back the client-side stretching parameters. Once an account was upgraded to use a longer stretch, they could no longer be accessed by v1 clients. The server could know this and return errors to v1 clients (incidentally learning the default-stretched authPW in the process)."),(0,i.kt)("h2",{id:"two-password-extension"},"two-password extension"),(0,i.kt)("p",null,'One proposal to address the "Use of Password in a Web Context" weakness above is to introduce an optional second password, with improved security. The general idea is to feed the second password into the original SRP protocol (client-side scrypt, SRP-protected exchange of strong wrapped kB). The second password would only be used for Sync (not for plain Firefox Account login), and only entered into chrome UI (never into web content).'),(0,i.kt)("p",null,"The API to perform SRP will be gated by the sessionToken, as will use of the scrypt-helper, which could marginally improve our DoS story."),(0,i.kt)("p",null,"If we implement this, it will require a ",(0,i.kt)("inlineCode",{parentName:"p"},"/v2")," API call to use. When an account is configured for a second password, the ",(0,i.kt)("inlineCode",{parentName:"p"},"/v2/account/login?keys=true")," request will return an error or a field to that effect, instead of a keyFetchToken. Changing from one password to two, or vice versa, will involve extra API calls. Using the first-generation ",(0,i.kt)("inlineCode",{parentName:"p"},"/v1")," API on such an account will return an error that says you must use a newer client."),(0,i.kt)("p",null,'Use of a second password will restore all the security properties of the earlier SRP-based protocol: only the scrypt-helper gets the "easy" brute-force attack, and the only "hard" brute-force attacks are available to a malicious active server or a TLS-level eavesdropper on the create-account and forgot-password flows. kA is protected from all eavesdroppers.'),(0,i.kt)("h2",{id:"pairing-extension"},"pairing extension"),(0,i.kt)("p",null,"An even stronger improvement would be to re-introduce an optional pairing flow. When this is enabled for the first time, the client will produce a strong random key and include it in the derivation of unwrapBkey. The server will make a note of the fact that pairing is enabled. When connecting later devices, the client will see this flag and initiate the J-PAKE pairing UI to transfer the additional key."),(0,i.kt)("p",null,"This pairing flow can be better than the old-Sync flow because we have more information to work with. Depending upon how much the user types before we start the transfer, we may know an email address (reducing the number of candidate machines to talk to), and the account password (making it harder to for the attacker to participate in the pairing process). This will allow us to automatically pop up the pairing dialog on the sending machine, and to reduce the length of the sync code considerably (perhaps just a 4-digit PIN)."),(0,i.kt)("h1",{id:"delta-from-old-srp-protocol"},"delta from old SRP protocol"),(0,i.kt)("p",null,"The following endpoints are modified:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /account/create")," (gets authPW instead of srpV/srpSalt)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /account/reset")," (gets authPW instead of wrapKB/srpV/srpSalt, parameters are not encrypted)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /account/delete")," (gets authPW instead of HAWK-with-authtoken)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /password/change/start")," (gets old authPW, not authToken, returns passwordChangeToken instead of accountResetToken)")),(0,i.kt)("p",null,"these endpoints are added:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /password/change/finish")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /account/login")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /account/login?keys=true"))),(0,i.kt)("p",null,"and these are removed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /auth/start")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /auth/finish")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"POST /session/create")," (since sessionToken comes from /account/login)")),(0,i.kt)("h1",{id:"test-vectors"},"Test Vectors"),(0,i.kt)("h3",{id:"client-stretch-kdf"},"client stretch-KDF"),(0,i.kt)("p",null,"email:\n616e6472c3a94065\n78616d706c652e6f\n7267"),(0,i.kt)("p",null,"password:\n70c3a4737377c3b6\n7264"),(0,i.kt)("p",null,"quickStretchedPW:\ne4e8889bd8bd61ad\n6de6b95c059d56e7\nb50dacdaf62bd846\n44af7e2add84345d"),(0,i.kt)("p",null,"authPW:\n247b675ffb4c4631\n0bc87e26d712153a\nbe5e1c90ef00a478\n4594f97ef54f2375"),(0,i.kt)("p",null,"authSalt (normally random):\n00f0000000000000\n0000000000000000\n0000000000000000\n0000000000000000"),(0,i.kt)("p",null,"bigStretchedPW:\n441509e25c92ee10\n3d5a1a874e6f155d\nf25a44d06e61c894\n616c9e85181dba97"),(0,i.kt)("p",null,"verifyHash:\na4765bf103dc057f\n4cf4bc2c131ddb67\n16e8a4333cc55e1d\n3c449f31f0eec4f1"),(0,i.kt)("h3",{id:"accountkeys"},"/account/keys"),(0,i.kt)("p",null,"wrapwrapKey:\n3ebea117efa9faf5\n7ce195899b290505\n8368e7760cc26ea5\n8a2a1be0da7fb287"),(0,i.kt)("p",null,"unwrapBkey:\nde6a2648b78284fc\nb9ffa81ba9580330\n9cfba7af583c01a8\na1a63e567234dd28"),(0,i.kt)("p",null,"keyFetchToken:\n8081828384858687\n88898a8b8c8d8e8f\n9091929394959697\n98999a9b9c9d9e9f"),(0,i.kt)("p",null,"tokenID (keyFetchToken):\n3d0a7c02a15a62a2\n882f76e39b6494b5\n00c022a8816e0486\n25a495718998ba60"),(0,i.kt)("p",null,"reqHMACkey:\n87b8937f61d38d0e\n29cd2d5600b3f4da\n0aa48ac41de36a0e\nfe84bb4a9872ceb7"),(0,i.kt)("p",null,"keyRequestKey:\n14f338a9e8c6324d\n9e102d4e6ee83b20\n9796d5c74bb734a4\n10e729e014a4a546"),(0,i.kt)("p",null,"respHMACkey:\nf824d2953aab9faf\n51a1cb65ba9e7f9e\n5bf91c8d8fd1ac1c\n8c2d31853a8a1210"),(0,i.kt)("p",null,"respXORkey:\nce7d7aa77859b235\n9932970bbe2101f2\ne80d01faf9191bd5\nee52181d2f0b7809\n8281ba8cff392543\n3a89f7c3095e0c89\n900a469d60790c83\n3281c4df1a11c763"),(0,i.kt)("p",null,"kA:\n2021222324252627\n28292a2b2c2d2e2f\n3031323334353637\n38393a3b3c3d3e3f"),(0,i.kt)("p",null,"wrapkB:\n7effe354abecbcb2\n34a8dfc2d7644b4a\nd339b525589738f2\nd27341bb8622ecd8"),(0,i.kt)("p",null,"plaintext:\n2021222324252627\n28292a2b2c2d2e2f\n3031323334353637\n38393a3b3c3d3e3f\n7effe354abecbcb2\n34a8dfc2d7644b4a\nd339b525589738f2\nd27341bb8622ecd8"),(0,i.kt)("p",null,"ciphertext:\nee5c58845c7c9412\nb11bbd20920c2fdd\nd83c33c9cd2c2de2\nd66b222613364636\nfc7e59d854d599f1\n0e212801de3a47c3\n4333f3b838ee3471\ne0f285649c332bbb"),(0,i.kt)("p",null,"MAC:\n4c17f42a0b319bbb\na327d2b326ad23e9\n37219b4de32e3ec7\nb3e3f740522ad6ef"),(0,i.kt)("p",null,"response:\nee5c58845c7c9412\nb11bbd20920c2fdd\nd83c33c9cd2c2de2\nd66b222613364636\nfc7e59d854d599f1\n0e212801de3a47c3\n4333f3b838ee3471\ne0f285649c332bbb\n4c17f42a0b319bbb\na327d2b326ad23e9\n37219b4de32e3ec7\nb3e3f740522ad6ef"),(0,i.kt)("p",null,"wrapkB:\n7effe354abecbcb2\n34a8dfc2d7644b4a\nd339b525589738f2\nd27341bb8622ecd8"),(0,i.kt)("p",null,"unwrapBkey:\nde6a2648b78284fc\nb9ffa81ba9580330\n9cfba7af583c01a8\na1a63e567234dd28"),(0,i.kt)("p",null,"kB:\na095c51c1c6e384e\n8d5777d97e3c487a\n4fc2128a00ab395a\n73d57fedf41631f0"),(0,i.kt)("h3",{id:"use-session-certificatesign-etc"},"use session (certificate/sign, etc)"),(0,i.kt)("p",null,"sessionToken:\na0a1a2a3a4a5a6a7\na8a9aaabacadaeaf\nb0b1b2b3b4b5b6b7\nb8b9babbbcbdbebf"),(0,i.kt)("p",null,"tokenID (sessionToken):\nc0a29dcf46174973\nda1378696e4c82ae\n10f723cf4f4d9f75\ne39f4ae3851595ab"),(0,i.kt)("p",null,"reqHMACkey:\n9d8f22998ee7f579\n8b887042466b72d5\n3e56ab0c094388bf\n65831f702d2febc0"),(0,i.kt)("h1",{id:"glossary"},"Glossary"),(0,i.kt)("p",null,"This defines some of the jargon we've developed for this protocol."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Term"),(0,i.kt)("th",{parentName:"tr",align:null},"Definition"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"data classes"),(0,i.kt)("td",{parentName:"tr",align:null},"each type of browser data (bookmarks, passwords, history, etc) can be assigned, by the user, to either class-A or class-B.  Note that this user selection is not yet implemented by Firefox, and all data types are treated as class-B by default.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"class-A"),(0,i.kt)("td",{parentName:"tr",align:null},"data assigned to this class can be recovered, even if the user forgets their password, by proving control over an email address and resetting the account. It can also be read by Mozilla (since it runs the keyserver and knows kA), or by the user's IdP (by resetting the account without the user's permission).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"class-B"),(0,i.kt)("td",{parentName:"tr",align:null},"data in this class cannot be recovered if the password is forgotten. It cannot be read by the IdP. Mozilla (via the keyserver) cannot read this data, but can attempt a brute-force dictionary attack against the password.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"kA"),(0,i.kt)("td",{parentName:"tr",align:null},'the master key for data stored as "class-A", a 32-byte binary string. Individual encryption keys for different datatypes are derived from kA.')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"kB"),(0,i.kt)("td",{parentName:"tr",align:null},'the master key for data stored as "class-B", a 32-byte binary string.')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"wrap(kB)"),(0,i.kt)("td",{parentName:"tr",align:null},"an encrypted copy of kB. The keyserver stores wrap(kB) and never sees kB itself. The client (browser) uses a key derived from the user's password to decrypt wrap(kB), obtaining the real kB.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sessionToken"),(0,i.kt)("td",{parentName:"tr",align:null},"a long-lived per-device token which allows the device to obtained signed BrowserID certificates for the account's identity (",(0,i.kt)("a",{parentName:"td",href:"mailto:GUID@picl-something.org"},"GUID@picl-something.org"),'). This token remains valid until the user revokes it (either by changing their password, or triggering some kind of "revoke a specific device" or "revoke all devices" function).')))),(0,i.kt)("h1",{id:"references"},"References"),(0,i.kt)("p",null,"This file was last substantially edited in early 2014. Its commit history can be found in the old fxa-auth-server repo: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mozilla/fxa-auth-server/wiki/onepw-protocol"},"https://github.com/mozilla/fxa-auth-server/wiki/onepw-protocol")))}u.isMDXComponent=!0},81954:function(e,t,n){t.Z=n.p+"assets/images/IdPAuth-key-unwrap-3d96eed49e08a64f9d6a8e4a2d60f1fb.png"},28785:function(e,t,n){t.Z=n.p+"assets/images/IdPAuth-keys-client-177b546d88cd293a47dbad832552dd46.png"},36184:function(e,t,n){t.Z=n.p+"assets/images/IdPAuth-keys-server-5cac4afd0bd2f5126e14633595e98681.png"},52720:function(e,t,n){t.Z=n.p+"assets/images/IdPAuth-use-session-c3e15bc5f2a74d8877a21873d9bd97a3.png"},63144:function(e,t,n){t.Z=n.p+"assets/images/onepw-auth-dcdf1a8fd5aa71048ee5fa70cbec2f0d.png"},39951:function(e,t,n){t.Z=n.p+"assets/images/onepw-change-password-b7d9f3cb11fec4370b1a32d66d6a3043.png"},75865:function(e,t,n){t.Z=n.p+"assets/images/onepw-create-c9ae4cb4e6ae73a7472a8b0a5ff99bdf.png"},61627:function(e,t,n){t.Z=n.p+"assets/images/onepw-forgot-password-a7c45ad3d276615abc9bc43297ab1c73.png"},54287:function(e,t,n){t.Z=n.p+"assets/images/onepw-keys-a71ea1e76c87bf54724c0dc14f68283a.png"},8147:function(e,t,n){t.Z=n.p+"assets/images/onepw-reset-cac09f370da38207c26c444a4055f60e.png"}}]);